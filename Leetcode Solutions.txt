|| Leetcode Solutions||

*Day-1* 

Q. Two Sum--------

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> idx;
    vector<int> result;
    
    for (int i = 0; i < nums.size(); i++) 
    {
        int complement = target - nums[i];
        if (idx.find(complement) != idx.end()) 
        {
            result.push_back(idx[complement]);
            result.push_back(i);
            break;
        }
        idx[nums[i]] = i;
    }
    
    return result;
    }
};

-------------------------------------------------

Q. Reverse Integer------


class Solution {
public:
    int reverse(int x) {
        long sum =0, rem;
        while(x)
        {
            rem = x % 10;
            sum = sum * 10 + rem;
            x = x /10;

            if(sum >= INT_MAX || sum <= INT_MIN) return 0;
        }
        return sum;
        
    }
};
-------------------------------------------------

|| *DAY-2* ||

Q. Palindrome Number ------

class Solution {
public:
    bool isPalindrome(int x) {
        long int sum = 0, rem;
        long int temp = x;
        while ( x>0)
        {
            rem = x % 10;
            sum = sum * 10 + rem;
            x /= 10;
        }
        return (sum == temp);
        
    }
};
------------------------------------------------

Q. Valid Parenthesis ------

class Solution {
public:
    bool isValid(string s) {
        
    stack<char> st;
    
    for(char c : s){
        if(c == '{' || c == '[' || c == '(')
        {
            st.push(c);
        }
        else{
        if (st.empty() || 
                    (c == ')' && st.top() != '(') || 
                    (c == '}' && st.top() != '{') ||
                    (c == ']' && st.top() != '[')) {
                    return false;
                }
             st.pop();
        }
    }
    return st.empty();
    }  
};
--------------------------------------------------

|| *DAY-3* ||

Q. Power of Two ------


class Solution {
public:
    bool isPowerOfTwo(int n) {
        if(n <= 0)return false;
        while(n != 1){
            if(n % 2 != 0)return false;
            n /= 2;
        }
        return true;
        
    }
};
---------------------------------------------------

Q. Power of Three -------

class Solution {
public:
    bool isPowerOfThree(int n) {
        if(n <= 0)return false;
        int num = 1;
        while(num < INT_MAX / 3){
            if( num == n) return true;
            num *= 3;
        }
        if ( num == n ) return true;
        return false;

        
    }
};
----------------------------------------------------

|| *DAY-4* ||

Q. Roman To Integer ------

class Solution {
public:
    int romanToInt(string s) {
        int ans = 0;
        unordered_map <char,int> mp { {'I',1}, {'V',5}, {'X',10}, {'L',50},
        {'C',100}, {'D',500}, {'M',1000}};

        for(int i = 0; i < s.size(); i++){
            if(mp[s[i]] < mp[s[i+1]]){
                ans = ans-mp[s[i]];
            }
            else{
                ans = ans+mp[s[i]];
            }
        }
        return ans;
        
    }
};
------------------------------------

Q. Plus One ------

class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n = digits.size();
        for(int i = n-1; i >= 0; i--){
            if(i == n-1)
            digits[i]++;
            if(digits[i] == 10){
                digits[i] = 0;
                if(i != 0){
                    digits[i-1]++;
                }
                else{
                    digits.push_back(0);
                    digits[i] = 1;
                }
            }
        }
        
        return digits;
    }
};
---------------------------------------------

|| *DAY-5* ||

Q. Add Digits -----

class Solution {
public:
    int addDigits(int num) {
        int sum = 0;
        int digit = 0;

        while (num>0){
            digit = num % 10;
            sum += digit;
            num /= 10;

        if(num == 0 && sum > 9) {
            num = sum;
            sum = 0;
        }
        }
        return sum;
    }
};
---------------------------------------

Q. Factorial Trailing Zeroes -----

class Solution {
public:
    int trailingZeroes(int n) {
        return n/5 + n/25 + n/125 + n/625 + n/3125;
    }
};
---------------------------------------

|| *DAY-6* ||

Q. Remove Element -----


class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int n = nums.size();
    vector<int>ans;
    for(int i =0; i<n; i++)
    {
        if(nums[i]==val)
        {
            continue;
        }
        else
        {
            ans.push_back(nums[i]);
        }
    }
    nums.clear();
    for(int i =0; i < ans.size(); i++)
    {
       nums.push_back(ans[i]);
    }
    return nums.size();
    }
};
-------------------------------------------

Q. Search Insert Position ------

class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
    int index = lower_bound(nums.begin(), nums.end(), target)-nums.begin();
        return index;
    }
};
--------------------------------------------

|| *DAY-7* ||

Q. Happy Number -----

class Solution {
public:
    bool isHappy(int n) {
      unordered_set<int>seen;

      while(n != 1 && seen.find(n) == seen.end()){
        seen.insert(n);
        int sum = 0;
        while(n != 0){
             int digit = n % 10;
             sum += digit * digit; 
             n /= 10;
        }
        n = sum;
      }  
      return n == 1;
        
    }
};
--------------------------------------

Q. Ugly Number -----

class Solution {
public:
    bool isUgly(int n) {
        if(n<=0) return false;
        while(n%2 ==0){
            n/=2;
        }
        while(n%3 ==0){
            n/=3;
        }
        while(n%5 ==0){
            n/=5;
        }
        return n == 1;
        
    }
};
------------------------------


|| *DAY-8* ||

Q. Single Number -----

class Solution {
public:
    int singleNumber(vector<int>& nums) {
    int result = 0;
    for(int i = 0; i < nums.size(); i++)
    {
        result ^= nums[i];
    }
    return result;

    }
};
-------------------------------

Q. Missing Number ------ 

class Solution {
public:
    int missingNumber(vector<int>& nums) {
    int sum = 0, n = nums.size(), actual_sum = 0, expected_sum = n*(n+1)/2;

    for(int i = 0; i < n; i++)
    {
        actual_sum = actual_sum + nums[i];
    }
    sum = expected_sum - actual_sum;
    return sum;
    }
};
-------------------------------

|| *DAY-9* ||

Q. Score of a String -----

class Solution {
public:
    int scoreOfString(string s) {
        int score = 0;
        for(int i = 1; i < s.size(); i++)
        {
          int diff = abs(static_cast<int>(s[i]) - static_cast<int>(s[i - 1]));
          score += diff;
        }
        
        return score;
    }
};
------------------------------------

Q. Add String ------

class Solution {
public:
    string addStrings(string num1, string num2) {
        string result = "";
        int i = num1.size()-1, j = num2.size()-1, carry = 0;

        while( i >= 0 || j >= 0 || carry != 0)
        {
            int sum = 0;
            if(i >= 0)
            {
                sum += (num1[i] - '0');
                i--;
            }
            if (j >= 0)
            {
                sum += (num2[j] - '0');
                j--;
            }
            sum += carry;
            carry = sum / 10;
            sum = sum % 10;
            result = to_string(sum) + result;
        }
        return result;
    }
};
---------------------------------------

|| *DAY-10* ||

Q. Max Consecutive Ones -------

class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
         int maxCount = 0;
    int count = 0;
    
    for (int num : nums) 
    {
        if (num == 1) 
        {
            count++;
            maxCount = max(maxCount, count);
        } 
        else 
        {
            count = 0;
        }
    }
    
    return maxCount;
    }
};
----------------------------------------

Q. Maximum Nesting Depth of the Parentheses ------

class Solution {
public:
    int maxDepth(string s) {
        int n = s.size();
        int oc = 0;
        int ans = 0;
        int i =0;
        while (i<n)
        {
            if(s[i]=='(')
            {
                oc++;
                ans=max(oc,ans);
            }
            if(s[i]==')')
            {
                oc--;
            }
            i++;
        }
        return ans;
    }
};
---------------------------------------------

|| *DAY-10* ||

Q. Running Sum of 1d Array ------


class Solution {
public:
    vector<int> runningSum(vector<int>& nums) {
        int n = nums.size();
        for(int i =1; i <n; i++)
        {
            nums[i] += nums[i-1];
        }
        return nums;
    }
};
------------------------------------------

Q. Find Peak Element ------

class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();
        if(n == 1)
        return 0;
        if(nums[0]>nums[1]) 
        return 0;
        if(nums[n-1]>nums[n-2]) 
        return n-1;
        int s = 1, e = n-2;
        while(s<=e)
        {
         int mid = (s + e) /2;
         cout << mid;
         if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]) 
         {
            cout << mid;
            return mid;
         }
         if(nums[mid]>nums[mid-1] && nums[mid]<nums[mid+1]) 
         {
            s = mid+1;
         }
         else
         {
            e = mid-1;
         }
        }
       return -1;
    }
};
----------------------------------------

|| *Day-12* ||

Q. Fibonacci Number --------

class Solution {
public:
    int fib(int n) {
        int num, n1 = 0 ,n2 = 1;
        if(n == 1 )
        return 1;
        if(n == 0)
        return 0;
        for(int i = 2; i <= n; i++)
        {
            num = n1 + n2;
            n1 = n2;
            n2 = num;
        }
        return num;
        
    }
};
-------------------------------------

Q. Search a 2D Matrix -------

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();
        int s = 0, e = m*n -1;
        while ( s<= e)
        {
            int mid = s+((e-s)/2);
            int row = mid / n, col = mid % n;
            if(matrix[row][col] == target)
            {
                return true;
            }
            else if ( target > matrix[row][col])
            {
                s = mid +1 ;
            }
            else 
            {
                e = mid -1 ;
            }
        }
        return false;
    }
};
------------------------------------------

|| *Day-13* ||

Q. Matrix Diagonal Sum -----

class Solution {
public:
    int diagonalSum(vector<vector<int>>& mat) {
        int n = mat.size();
        int sum = 0;
        for (int i = 0; i < n; i++)
        sum += mat[i][i] + mat[i][n-i-1];
        if(n % 2) sum -= mat[n/2][n/2];
        return sum;
    }
};
------------------------------------------

Q. Convert 1D Array Into 2D Array -------

class Solution {
public:
    vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {
        int N = original.size();
        if ( N != m*n)
        return {};

        vector<vector<int>>ans(m, vector<int>(n));

        int x = 0;
        for(int i =0; i < m; i++)
        {
            for(int j = 0; j < n; j++)
            {
                ans[i][j] = original[x++];
            }
        } 
        return ans;
    }      
};
---------------------------------------------

|| *Day-14* ||

Q. Number of Good Pairs ------

class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        int n = nums.size();
        int count = 0;
        pair<int,int>p;
        for(int i = 0; i < n; i++)
        {
            for(int j = i+1; j < n; j++)
            {
                if(nums[i]==nums[j] && i<j)
                {
                p = make_pair(i,j);
                count++;
                }
            }
        }
       return count; 
    }
};
--------------------------------------

Q. Find Peak Element ----- 

class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();
        if(n == 1)
        return 0;
        if(nums[0]>nums[1]) 
        return 0;
        if(nums[n-1]>nums[n-2]) 
        return n-1;
        int s = 1, e = n-2;
        while(s<=e)
        {
         int mid = (s + e) /2;
         cout << mid;
         if(nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]) 
         {
            cout << mid;
            return mid;
         }
         if(nums[mid]>nums[mid-1] && nums[mid]<nums[mid+1]) 
         {
            s = mid+1;
         }
         else
         {
            e = mid-1;
         }
        }
       return -1;
    }
};
----------------------------------------

|| *Day-15* ||

Q. Move Zeroes -------

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int count = 0;
        for (int i =0; i < nums.size(); i++){
            if(nums[i] == 0){
                count++;
                nums.erase(nums.begin() + i);
                i--;
            }
        }
        for(int i = 0; i < count; i++){
            nums.push_back(0);
        }
    }
};
---------------------------------------

Q. Single Element in a Sorted Array --------






